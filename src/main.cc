#include <v8.h>
#include <node.h>
#include <nan.h>

#include "util.h"
#include "crcwrapper.h"
#include "aeswrapper.h"

/**
* The following header | source files are automatically generated by tools.
* Uncomment some of them to involve them in the build (DO NOT forget changing the binding.gyp file as well)
* To re-generate these files, please go into tools folder and run the command (they may require the npm component "tokenizer"):
*
* $ node parsecpp.js
* $ node genwrapper.js
*/

// #include "crc_wrapper.h"
// #include "aes_xts_wrapper.h"
// #include "erasure_code_wrapper.h"
// #include "gf_vect_mul_wrapper.h"
// #include "igzip_lib_wrapper.h"
// #include "mb_md5_wrapper.h"
// #include "mb_sha1_wrapper.h"
// #include "mb_sha256_wrapper.h"
// #include "mb_sha512_wrapper.h"
// #include "md5_mb_wrapper.h"
// #include "mem_routines_wrapper.h"
// #include "raid_wrapper.h"
// #include "sha1_mb_wrapper.h"
// #include "sha256_mb_wrapper.h"
// #include "sha512_mb_wrapper.h"
// #include "sha_wrapper.h"


using namespace v8;

NAN_METHOD(GenBuffer) {
  NanScope();
  if (args.Length() != 1 || !args[0]->IsNumber()) {
    NanThrowTypeError("Invalid arguments");
    NanReturnUndefined();
  }
  uint32_t len = args[0]->Uint32Value();
  if (len == 0) {
    NanReturnUndefined();
  }
  node::Buffer *slowBuf = node::Buffer::New(len);
  if (len > 12) {
    // test
    memcpy(node::Buffer::Data(slowBuf), "Hello Buffer", 12);
  }
  Local<Object> globalObj = Context::GetCurrent()->Global();
  Local<Function> ctr = Local<Function>::Cast(globalObj->Get(NanNew("Buffer")));
  Handle<Value> ctrArgs[3] = {slowBuf->handle_, Integer::New(len), Integer::New(0)}; // last is offset
  Local<Object> actualBuf = ctr->NewInstance(3, ctrArgs);
  NanReturnValue(actualBuf);
  //Local<Value> val = NanNew("Hello Buffer");
  //NanReturnValue(val);
}

NAN_METHOD(PrintBuffer) {
  NanScope();
  if (args.Length() != 1 || !args[0]->IsObject()) {
    NanThrowTypeError("Invalid arguments");
    NanReturnUndefined();
  }
  Local<Object> bufObj = args[0]->ToObject();
  char *buf = node::Buffer::Data(bufObj);
  int len = node::Buffer::Length(bufObj);
  buf[len - 1] = 0;
  printf("%d: %s\n", len, buf);
  NanReturnUndefined();
}


void Initialize(Handle<Object> exports) {
  //Isolate *isolate = Isolate::GetCurrent();
  //exports->Set(String::NewFromUtf8(isolate, "generateBuffer"), 
  //    FunctionTemplate::New(isolate, GenBuffer)->GetFunction());
  exports->Set(NanNew("generateBuffer"), NanNew<FunctionTemplate>(GenBuffer)->GetFunction());
  exports->Set(NanNew("printBuffer"), NanNew<FunctionTemplate>(PrintBuffer)->GetFunction());

  export_util_component(exports);
  exportCRCComponent(exports);
  exportAESComponent(exports);

  // Uncomment some of them and uncomment their header files at the top of this file
  
  // export_aes_xts_component(exports);
  // export_erasure_code_component(exports);
  // export_crc_component(exports);
  // export_gf_vect_mul_component(exports);
  // export_igzip_lib_component(exports);
  // export_mb_md5_component(exports);
  // export_mb_sha1_component(exports);
  // export_mb_sha256_component(exports);
  // export_mb_sha512_component(exports);
  // export_md5_mb_component(exports);
  // export_mem_routines_component(exports);
  // export_raid_component(exports);
  // export_sha1_mb_component(exports);
  // export_sha256_mb_component(exports);
  // export_sha512_mb_component(exports);
  // export_sha_component(exports);
}

NODE_MODULE(isal, Initialize)

